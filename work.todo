1. monday ko profile check krna hai functionality kaam nhi kr rha hai 
usko fix krna hai 

2. admin-dashboard me appointment me agr user new hai to uska data db me save krna hai ✅

3 write do in addnewappointment component ✅

4. Running appoitment ko daily entry me show krna hai 


in staff history i have to put half_day on leave ke jagah pe 






// kal ke liye 


Build a Salon Admin Dashboard - Services Management Component.

Requirements:
Top Summary Section:

Display Total Services (count of all active services).

Services Table:

Columns to display:

Service Name (text)

Time Duration (e.g., 30 min, 1 hour – dropdown or text input)

Base Price (numeric input with currency formatting)

Description (text input with max 30 characters)

Delete Flag (toggle switch for soft delete)

Created At (timestamp)

Include search bar, sorting by columns, and filter for active/deleted services.

Add New Service Section:

Form fields:

Service Name

Time Duration

Base Price

Description (limit 30 characters, show character counter)

Save button to add the new service to the list dynamically.

UI Style & Tech Stack:

Use React + TailwindCSS for styling.

Use Framer Motion for smooth animations and transitions.

Dashboard should be fully responsive (desktop, tablet, mobile).

Extra Features (Optional):

Confirmation modal before deleting a service.

Export services list as CSV or Excel.

Pagination if services exceed a certain count.





today date = 28-08-2025


favicon change krna hai

auth me logo ko change krna hai

footer daalna hai 

sms ko fix krna hai 




this is comming from the whatsapp and i have to read it fully 


Bahut badhiya — accha plan hai. Main poora roadmap, DB schema, relations, access-control, sample SQL aur API / backend flow de raha hoon — Hinglish mein aur seedha practical. Maine tumhare existing tables ko bhi include kiya aur missing pieces add kiye (jaise shop/branch, roles, service_price, etc.) taki multi-shop + admin/staff permissions sahi se kaam kare.

Summary (ek line)

Har record shop_id se belong karega; queries aur middleware se ensure karo ki user (admin ya staff) sirf apne shop_id ka data dekh sake. Optionally Postgres Row-Level Security (RLS) use karo for stronger DB-level tenancy.

1) Core concept — Multi-tenant (shared DB) approach (recommended)

Single database, sab tables mein shop_id foreign key.

App middleware validates JWT and provides user_id, role, shop_id.

Har query me WHERE shop_id = :current_shop_id.

Staff ko extra restriction: agar role = staff to aur bhi restrict karo (e.g. staff_id = :current_staff_id where needed).

(Alternate: separate DB per shop — zyada complexity, unless bahut large scale.)

2) Tables & Relationships (ER overview)

Main tables (aur relation summary):

shops (1) —< profiles (admins) (many)

shops (1) —< staff_info (many)

shops (1) —< appointments (many)

customers —< appointments (1-to-many)

hair_service —< service_price (service price per shop) —< appointments (service attached)

inventory belongs to shops

staff_attendance links to staff_info

profiles holds login credentials / role (admin/staff) or separate users table, linked to staff_info when role=staff

3) Suggested DB schema (Postgres style) — key columns + indexes
-- shops (each salon/branch)
CREATE TABLE shops (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  address TEXT,
  phone TEXT,
  timezone TEXT DEFAULT 'Asia/Kolkata',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  is_active BOOLEAN DEFAULT TRUE
);

-- users / profiles (people who can login: admins & staff)
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  shop_id UUID REFERENCES shops(id) ON DELETE CASCADE,
  email TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  full_name TEXT,
  role TEXT NOT NULL CHECK (role IN ('admin','staff')), -- extendable
  staff_id UUID NULL, -- if role = staff, link to staff_info.id
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_users_shop ON users(shop_id);

-- staff_info (details about staff)
CREATE TABLE staff_info (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  shop_id UUID REFERENCES shops(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  phone TEXT,
  specialties TEXT[], -- e.g. ['cut','color']
  hourly_rate NUMERIC(10,2),
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_staff_shop ON staff_info(shop_id);

-- customers
CREATE TABLE customers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  shop_id UUID REFERENCES shops(id) ON DELETE CASCADE,
  name TEXT,
  phone TEXT,
  email TEXT,
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_customers_shop ON customers(shop_id);

-- hair_service (master list of services)
CREATE TABLE hair_service (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  code TEXT UNIQUE,
  name TEXT NOT NULL,
  description TEXT,
  default_duration_minutes INT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- service_price (price of service in a shop)
CREATE TABLE service_price (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  shop_id UUID REFERENCES shops(id) ON DELETE CASCADE,
  service_id UUID REFERENCES hair_service(id),
  price NUMERIC(10,2) NOT NULL,
  duration_minutes INT, -- override possible
  is_active BOOLEAN DEFAULT TRUE
);
CREATE INDEX idx_serviceprice_shop ON service_price(shop_id);

-- appointments
CREATE TABLE appointments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  shop_id UUID REFERENCES shops(id) ON DELETE CASCADE,
  customer_id UUID REFERENCES customers(id),
  service_price_id UUID REFERENCES service_price(id),
  staff_id UUID REFERENCES staff_info(id), -- optional (unassigned appointment allowed)
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('scheduled','completed','cancelled','no_show')),
  created_by UUID REFERENCES users(id), -- who created it
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_appt_shop_start ON appointments(shop_id, start_time);
CREATE INDEX idx_appt_staff_start ON appointments(staff_id, start_time);

-- staff_attendance
CREATE TABLE staff_attendance (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  shop_id UUID REFERENCES shops(id) ON DELETE CASCADE,
  staff_id UUID REFERENCES staff_info(id),
  date DATE NOT NULL,
  time_in TIMESTAMPTZ,
  time_out TIMESTAMPTZ,
  notes TEXT
);
CREATE INDEX idx_attendance_staff_date ON staff_attendance(staff_id, date);

-- inventory
CREATE TABLE inventory (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  shop_id UUID REFERENCES shops(id) ON DELETE CASCADE,
  sku TEXT,
  name TEXT,
  quantity INT DEFAULT 0,
  min_threshold INT DEFAULT 0,
  last_updated TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_inventory_shop ON inventory(shop_id, sku);

-- audit / soft delete fields: add deleted_at TIMESTAMPTZ NULL to important tables if want soft delete


Note: users.staff_id optional: helps link login to staff record. For admin, staff_id is NULL or link to an admin profile if you want.

4) Relations explained (simple)

users.shop_id = shops.id → user belongs to a shop

staff_info.shop_id = shops.id → staff belongs to shop

customers.shop_id = shops.id → customers per shop

service_price.shop_id = shops.id → service pricing per shop

appointments.shop_id = shops.id AND appointments.staff_id -> staff assigned

Always query using WHERE shop_id = :current_shop_id to restrict.

5) Access control & middleware (backend)

Auth: JWT with payload { user_id, shop_id, role, staff_id? }.

Middleware (global): decode JWT -> set req.currentUser = {user_id, shop_id, role, staff_id}.

Authorization rules:

Admin: can CRUD everything for their shop_id.

Staff: can view/modify only allowed resources:

e.g., staff can see:

appointments where shop_id = staff.shop_id AND (staff_id = current_staff_id or role allows seeing others' schedules if given permission).

their own attendance (staff_id).

customers created by them or customers of shop (decide policy).

Query example (Node/ORM pseudo):

// get appointments visible to the user
if (user.role === 'admin') {
  db.query('SELECT * FROM appointments WHERE shop_id = $1', [user.shop_id]);
} else {
  // staff
  db.query('SELECT * FROM appointments WHERE shop_id = $1 AND staff_id = $2', [user.shop_id, user.staff_id]);
}


Important: Never trust client-provided shop_id. Always read it from JWT/session.

6) Postgres Row-Level Security (optional but powerful)

Create policies so that SELECT/UPDATE/DELETE are allowed only when shop_id = current_setting('app.current_shop')::uuid or using SET LOCAL session var. Or policies referencing auth.uid() in Supabase.

This moves enforcement into DB layer.

7) Appointment booking conflicts / availability

Use transaction with a SELECT FOR UPDATE or optimistic check before insert to avoid double-booking same staff/time.

Example to check conflicts:

SELECT 1 FROM appointments
WHERE staff_id = :staff_id
  AND shop_id = :shop_id
  AND status = 'scheduled'
  AND tstzrange(start_time, end_time) && tstzrange(:start, :end);


If returns row => conflict.

8) Example queries you will need

Admin: view all shop appointments (paginated)

SELECT a.*, c.name as customer_name, s.name as service_name, st.name as staff_name
FROM appointments a
JOIN customers c ON c.id = a.customer_id
JOIN service_price sp ON sp.id = a.service_price_id
JOIN hair_service s ON s.id = sp.service_id
LEFT JOIN staff_info st ON st.id = a.staff_id
WHERE a.shop_id = :shop_id
ORDER BY a.start_time DESC
LIMIT 50 OFFSET 0;


Staff: view only their upcoming appointments

SELECT * FROM appointments
WHERE shop_id = :shop_id
  AND staff_id = :staff_id
  AND start_time >= now()
ORDER BY start_time;


Staff: check-in attendance

INSERT INTO staff_attendance (shop_id, staff_id, date, time_in) VALUES (:shop_id, :staff_id, current_date, now());

9) Backend API endpoints (example)

POST /api/auth/login → returns JWT with shop_id, role, staff_id

GET /api/appointments → returns appointments filtered by req.currentUser (middleware enforces)

POST /api/appointments → create appointment (validate shop_id from user, check conflicts)

PATCH /api/appointments/:id → update (verify shop_id & permissions)

DELETE /api/appointments/:id → soft-delete or cancel

GET /api/staff → admin: list staff (shop_id restricted); staff: maybe return only their profile

GET /api/inventory → restricted by shop_id

POST /api/staff_attendance → create check-in/out

10) Indexing & performance

Index on (shop_id, start_time) for appointments.

Index on staff_id, start_time for conflict checks.

Index users(email) unique.

Add partial indexes for active rows if many soft-deleted entries.

11) Extra features & best practices

Audit logs: appointment_audit table to track who changed status/time.

Soft delete: deleted_at TIMESTAMPTZ so you can recover.

Timezone handling: store TIMESTAMPTZ and keep shops.timezone. Convert UI times according to shop timezone.

Roles & permissions table (if you want granular perms later).

Service durations: compute end_time = start_time + service.duration (store both start & end).

Notifications: schedule SMS/WhatsApp reminders (store reminder_sent_at).

Concurrency: when reducing inventory.quantity use UPDATE inventory SET quantity = quantity - :n WHERE id = :id AND quantity >= :n and check rows affected.

12) Sample small flow — Create Appointment (detailed)

Frontend sends POST /api/appointments with customer, service_price_id, staff_id, preferred_start.

Server middleware authenticates -> user.shop_id.

Server loads service_price for service_price_id and checks shop_id matches current shop.

Compute end_time = start + duration.

Begin transaction:

Check conflicts:

SELECT 1 FROM appointments WHERE shop_id = :shop_id AND staff_id = :staff_id AND status='scheduled'
  AND tstzrange(start_time,end_time) && tstzrange(:start,:end);


If none, insert appointment with shop_id = user.shop_id, created_by = user.id.

Commit and return created appointment.

13) Minimal front-end rules (auth + UI)

On login store JWT (httpOnly cookie recommended). JWT contains shop_id, role, staff_id.

In all API calls, backend uses JWT to filter — never pass shop_id from frontend.

UI: admin dashboard shows shop-wide stats; staff dashboard shows only their appointments/attendance.

14) Example of protecting against cross-shop leak

Problem: staff of shop A sees shop B data.
Fixes:

Add shop_id FK on all tenant tables.

Middleware enforces shop_id from JWT.

In SQL queries always include WHERE shop_id = :user.shop_id.

Optionally use Postgres RLS to enforce at DB level (recommended if high risk).

15) Small checklist to implement (roadmap)

Add shops table and ensure all existing tables have shop_id (backfill for existing data).

Create users table for login, link staff users to staff_info.

Implement JWT auth and middleware to attach req.currentUser.

Change all queries to enforce shop_id.

Implement appointment conflict checks and transactional inserts.

Add indices and test performance.

Add tests: staff cannot access other shop's data (integration tests).

Implement optional RLS for stronger enforcement.

Add UI restrictions based on role.

Add audit logs & soft-delete.

16) Quick examples — protect endpoints (Node/Express pseudo)
// middleware
function authMiddleware(req, res, next) 
  const token = req.headers.authorization?.split(' ')[1];
  const payload = verifyJwt(token); // contains user_id, shop_id, role, staff_id
  req.user = payload;
  next();
}

// route
app.get('/api/appointments', authMiddleware, async (req, res) => {
  const { shop_id, role, staff_id } = req.user;
  if (role === 'admin') {
    const rows = await db.query('SELECT * FROM appointments WHERE shop_id=$1', [shop_id]);
    res.json(rows);
  } else {
    const rows = await db.query('SELECT * FROM appointments WHERE shop_id=$1 AND staff_id=$2', [shop_id, staff_id]);
    res.json(rows);
  }
});

17) Final tips / gotchas

Never trust front-end shop_id. Always server derive from JWT.

Keep created_by fields to know who created/edited.

Use transactions for booking & inventory updates.

Decide policy on whether staff can see other staff schedules — implement role/permission flags if needed.

Consider using ORM (Prisma/TypeORM) to map relations and simplify queries; still enforce shop_id filters.

Agar chaho to main abhi tumhare existing tables ke hisaab se:

ek migration SQL bana ke de sakta hoon jo shop_id add kare aur constraints lagaye,

ya ek sample Express/Next.js middleware + Prisma model file bana ke de doon.

Kaunsa chahiye? (main seedha bana ke dedunga — batao migration chahiye ya backend middleware + prisma models? )












date --> 3/9/2025



add appointment is not working ✅

transatoin page me desktop me scroll nhi dikhna chaiye 
but mobile me nhi hai 


running appointment me stuck ho jaa rha hai page 


todo likho staffDb.jsx me waha position data db se ayega


check the staff payment page waha jo mobile me jaisa card dikh rha hai 
waise same krna hai 
pure website me jaha jaha table hai 


